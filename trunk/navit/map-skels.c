/*
 * This file was generated by orbit-idl-2 - DO NOT EDIT!
 */

#include <string.h>
#define ORBIT2_STUBS_API
#include "map.h"

static ORBitSmallSkeleton
get_skel_small_Mappel(POA_Mappel * servant,
		      const char *opname, gpointer * m_data, gpointer * impl)
{
   switch (opname[0]) {
     case 'T':
	if (strcmp((opname + 1), "est"))
	   break;
	*impl = (gpointer) servant->vepv->Mappel_epv->Test;
	*m_data = (gpointer) & Mappel__iinterface.methods._buffer[0];
	return (ORBitSmallSkeleton) _ORBIT_skel_small_Mappel_Test;
	break;
     default:
	break;
   }
   return NULL;
}

void
POA_Mappel__init(PortableServer_Servant servant, CORBA_Environment * env)
{
   static PortableServer_ClassInfo class_info =
      { NULL, (ORBit_small_impl_finder) & get_skel_small_Mappel,
"IDL:Mappel:1.0", &Mappel__classid, NULL, &Mappel__iinterface };
   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
				    env);
   ORBit_skel_class_register(&class_info, servant, POA_Mappel__fini,
			     ORBIT_VEPV_OFFSET(POA_Mappel__vepv, Mappel_epv),
			     (CORBA_unsigned_long) 0);
}

void
POA_Mappel__fini(PortableServer_Servant servant, CORBA_Environment * env)
{
   PortableServer_ServantBase__fini(servant, env);
}

static ORBitSmallSkeleton
get_skel_small_Map(POA_Map * servant,
		   const char *opname, gpointer * m_data, gpointer * impl)
{
   switch (opname[0]) {
     case 'G':
	if (strcmp((opname + 1), "et"))
	   break;
	*impl = (gpointer) servant->vepv->Map_epv->Get;
	*m_data = (gpointer) & Map__iinterface.methods._buffer[8];
	return (ORBitSmallSkeleton) _ORBIT_skel_small_Map_Get;
	break;
     case 'P':
	switch (opname[1]) {
	  case 'l':
	     if (strcmp((opname + 2), "aceFlag"))
		break;
	     *impl = (gpointer) servant->vepv->Map_epv->PlaceFlag;
	     *m_data = (gpointer) & Map__iinterface.methods._buffer[3];
	     return (ORBitSmallSkeleton) _ORBIT_skel_small_Map_PlaceFlag;
	     break;
	  case 'o':
	     if (strcmp((opname + 2), "intFromCoord"))
		break;
	     *impl = (gpointer) servant->vepv->Map_epv->PointFromCoord;
	     *m_data = (gpointer) & Map__iinterface.methods._buffer[4];
	     return (ORBitSmallSkeleton) _ORBIT_skel_small_Map_PointFromCoord;
	     break;
	  default:
	     break;
	}
	break;
     case 'R':
	if (strcmp((opname + 1), "oute"))
	   break;
	*impl = (gpointer) servant->vepv->Map_epv->Route;
	*m_data = (gpointer) & Map__iinterface.methods._buffer[7];
	return (ORBitSmallSkeleton) _ORBIT_skel_small_Map_Route;
	break;
     case 'V':
	switch (opname[1]) {
	  case 'i':
	     switch (opname[2]) {
	       case 'e':
		  switch (opname[3]) {
		    case 'w':
		       switch (opname[4]) {
			 case '\0':
			    *impl = (gpointer) servant->vepv->Map_epv->View;
			    *m_data =
			       (gpointer) & Map__iinterface.methods.
			       _buffer[5];
			    return (ORBitSmallSkeleton)
			       _ORBIT_skel_small_Map_View;
			    break;
			 case 'A':
			    if (strcmp((opname + 5), "ll"))
			       break;
			    *impl =
			       (gpointer) servant->vepv->Map_epv->ViewAll;
			    *m_data =
			       (gpointer) & Map__iinterface.methods.
			       _buffer[6];
			    return (ORBitSmallSkeleton)
			       _ORBIT_skel_small_Map_ViewAll;
			    break;
			 default:
			    break;
		       }
		       break;
		    default:
		       break;
		  }
		  break;
	       default:
		  break;
	     }
	     break;
	  default:
	     break;
	}
	break;
     case 'd':
	switch (opname[1]) {
	  case 'o':
	     switch (opname[2]) {
	       case 'N':
		  if (strcmp((opname + 3), "othing"))
		     break;
		  *impl = (gpointer) servant->vepv->Map_epv->doNothing;
		  *m_data = (gpointer) & Map__iinterface.methods._buffer[1];
		  return (ORBitSmallSkeleton) _ORBIT_skel_small_Map_doNothing;
		  break;
	       case 'O':
		  if (strcmp((opname + 3), "neWay"))
		     break;
		  *impl = (gpointer) servant->vepv->Map_epv->doOneWay;
		  *m_data = (gpointer) & Map__iinterface.methods._buffer[2];
		  return (ORBitSmallSkeleton) _ORBIT_skel_small_Map_doOneWay;
		  break;
	       default:
		  break;
	     }
	     break;
	  default:
	     break;
	}
	break;
     case 'm':
	if (strcmp((opname + 1), "apString"))
	   break;
	*impl = (gpointer) servant->vepv->Map_epv->mapString;
	*m_data = (gpointer) & Map__iinterface.methods._buffer[0];
	return (ORBitSmallSkeleton) _ORBIT_skel_small_Map_mapString;
	break;
     default:
	break;
   }
   return NULL;
}

void
POA_Map__init(PortableServer_Servant servant, CORBA_Environment * env)
{
   static PortableServer_ClassInfo class_info =
      { NULL, (ORBit_small_impl_finder) & get_skel_small_Map, "IDL:Map:1.0",
&Map__classid, NULL, &Map__iinterface };
   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
				    env);
   ORBit_skel_class_register(&class_info, servant, POA_Map__fini,
			     ORBIT_VEPV_OFFSET(POA_Map__vepv, Map_epv),
			     (CORBA_unsigned_long) 0);
}

void
POA_Map__fini(PortableServer_Servant servant, CORBA_Environment * env)
{
   PortableServer_ServantBase__fini(servant, env);
}
